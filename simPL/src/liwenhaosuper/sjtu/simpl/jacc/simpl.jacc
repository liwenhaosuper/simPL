
%package liwenhaosuper.sjtu.simpl.jacc
%class SimPLParser
%interface SimPLTokens	

/**
 Token part
**/
//type
%token INTEGER BOOLEAN UNIT IDENT
// COLONCOLON: ::,COLONEQUAL: :=
%token ',' ';' COLONCOLON COLONEQUAL
//nop  
//NOT: not
%token '~' NOT
//bop
//AND: and OR: or
%token '+' '-' '*' '/' '<' '>' '=' AND OR
//ALLOW: ->
%token '(' ')' ALLOW
%token '$'
//keyword
%token LET IN IF THEN ELSE WHILE DO END FST SND HEAD TAIL FUN TRUE FALSE NIL

// level from low to high:
%left ';' 
%right ALLOW
%right COLONEQUAL
%left COLONCOLON
%left AND OR
%left  '=' '>' '<'
%left  '+' '-'
%right '*' '/'
%left  NOT '~'
%left FST SND HEAD TAIL 


 
%type <Expression> expr
%type <Value> val

%type <Variable> IDENT

%start prog

%{
import liwenhaosuper.sjtu.simpl.syntax.*;
%} 

//grammer
%%

prog : expr { System.out.println("Start");app = $1;System.out.println(app);System.out.println("End");}
     ;

expr : IDENT			{ System.out.println("Ident:"+$1);$$ = $1;}
	 | val				{ System.out.println("Val:"+$1);$$ = $1; }
	 | expr COLONCOLON expr { System.out.println("List:"+$1+","+$2);$$ = new List($1,$3);	}
 	 | '(' expr ',' expr ')' { System.out.println("Pair:"+$2+","+$4);$$ = new Pair($2,$4); }
 	 | '(' expr expr ')'  { $$ = new Application($2,$3); }
 	 
 	 //binary operation: plus, minus, times, devide, biggerThan, lessThan, equal, and, or
 	 | expr '+' expr { System.out.println("Add:"+$1+","+$3);$$ = new BinaryOperation($1,$3,BinaryOperation.BinaryOperator.plus);} 
 	 | expr '-' expr { $$ = new BinaryOperation($1,$3,BinaryOperation.BinaryOperator.minus);} 
 	 | expr '*' expr { $$ = new BinaryOperation($1,$3,BinaryOperation.BinaryOperator.times); } 
 	 | expr '/' expr { $$ = new BinaryOperation($1,$3,BinaryOperation.BinaryOperator.devide); } 
 	 | expr '=' expr { $$ = new BinaryOperation($1,$3,BinaryOperation.BinaryOperator.equal); } 
 	 | expr '>' expr { $$ = new BinaryOperation($1,$3,BinaryOperation.BinaryOperator.biggerThan); } 
 	 | expr '<' expr { $$ = new BinaryOperation($1,$3,BinaryOperation.BinaryOperator.lessThan); } 
 	 | expr AND expr { $$ = new BinaryOperation($1,$3,BinaryOperation.BinaryOperator.and); }
 	 | expr OR expr { $$ = new BinaryOperation($1,$3,BinaryOperation.BinaryOperator.or); }
 	 
 	 //unary operation  
 	 | '~' expr	{ $$ = new UnaryOperation($2,UnaryOperation.UnaryOperator.not);}
 	 | NOT expr	{ $$ = new UnaryOperation($2,UnaryOperation.UnaryOperator.negative);}
 	  
 	 | LET IDENT '=' expr IN expr END  { $$ = new LetInEnd($2,$4,$6); } 
 	 | IF expr THEN expr ELSE expr END  { $$ = new IfThenElse($2,$4,$6); }
 	 | expr COLONEQUAL expr { $$ = new Assignment($1,$3);} 
 	 | expr ';' expr { $$ = new Sequence($1,$3); } 
 	 | WHILE expr DO expr END  { $$ = new WhileDoEnd($2,$4);}
 	 | FST expr { $$ = new First($2); }
 	 | SND expr { $$ = new Second($2);}
 	 | HEAD expr { $$ = new Head($2); }
 	 | TAIL expr { $$ = new Tail($2);}
 	 | '(' expr ')'  { $$ = new Bracket($2); }
 	 ;

val  : INTEGER	{ $$ = $1; } /*new IntValue(Integer.parseInt($1))*/
	 | BOOLEAN  { $$ = $1;} /*new BoolValue(Boolean.parseBoolean($1))*/
	 | NIL	{ $$ = new Nil(); }
	 | '(' ')' { $$ = new Nop();} 
	 | FUN IDENT ALLOW expr { $$ = new AnonymousFunction($2,$4); }
	 //conflict
	 //| '(' val ',' val ')' { $$ = new PairValue($2,$4);}
	 //| val COLONCOLON val { $$ = new ListValue($1,$3); }  
	 ;	
%%
	private Expression app;
	private SimPLLexer lexer;
	SimPLParser(SimPLLexer lexer){
		this.lexer = lexer;
	}
	private void yyerror(String msg){
		lexer.error(msg);
	}
	public Expression getApp(){
		return app;
	}
	public static void main(String[] args){
		SimPLLexer lexer = new SimPLLexer();
		lexer.nextToken();
		SimPLParser parser = new SimPLParser(lexer);
		parser.parse();
	}